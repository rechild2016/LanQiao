#include <iostream>  
using namespace std;  
  
const int  m=12,n=15;//迷宫的大小  
int maze[m+2][n+2]={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,//输入迷宫地图  
                    1,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,1,  
                    1,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,  
                    1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,1,1,  
                    1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,  
                    1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,  
                    1,1,1,0,1,0,0,1,0,1,1,1,1,1,1,1,1,  
                    1,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,  
                    1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,  
                    1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,1,1,  
                    1,1,1,0,0,0,1,1,0,1,1,0,0,0,1,0,1,  
                    1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,1,  
                    1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,0,1,  
                    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};  
int mark[m+2][n+2];//设立迷宫是否走过标志  
int move[8][2]={{0,1},    //正东   i不变   j+1  向右    
                {1,1},    //右下    i+1   j+1    
                {1,0},    //下  i+1  j不变   
                {1,-1},   //  
                {0,-1},   //  
                {-1,-1},  //  
                {-1,0},   //  
                {-1,1}};  //  
//方向指标  
int SeekPath(int x,int y)  
{  
    int i,g,h;  
    if(x==1&&y==1) //如果到终点则找到路径,返回 1  
        return 1;  
    for (i=0;i<8;i++)//尝试每一个方向   
    {  
       g=x+move[i][0];  
       h=y+move[i][1]; //探索地点的新坐标   
         
       if(maze[g][h]==0&&mark[g][h]==0)//如果该地点走得通且没有被探索过  
       {  
           mark[g][h]=1;//将这一地点置为探索过   
           if(SeekPath(g,h))//从这一地点开始新的探索,如果成功  
           {  
              cout<<"("<<g<<","<<h<<")";//则打出这一点的坐标  
              if(move[i][0]==1) cout<<"North->";  
              if(move[i][0]==-1) cout<<"South->";  
              if(move[i][1]==1) cout<<"West->";  
              if(move[i][1]==-1) cout<<"East->";//判断前一地点到这一地点的方向  
              cout<<endl;  
              maze[g][h]=8;//把这一点设为通路   
              return 1;//返回1   
           }  
       }  
    }  
    if(x==m&&y==n)   
        cout<<"No path!"<<endl;//如果最后回到了起点,则说明没有通路   
    return 0;//返回0  
}  
   
int main()  
{  
    int i,j;  
    for (i=0;i<m+2;i++)  
       for (j=0;j<n+2;j++)  
           mark[i][j]=0;//先将所有通路置为没有走过  
             
    mark[m][n]=1;//将起点置为走过了  
    if(SeekPath(m,n)) //如果走通   
    {  
       cout<<"("<<m<<","<<n<<")"<<endl;//先打出起点坐标  
       maze[m][n]=8;//将起点设为通路  
       for (i=0;i<m+2;i++)  
           for (j=0;j<n+2;j++)  
           {  
              cout<<maze[i][j]<<" ";  
              if(j==n+1)   
                cout<<endl;  
           }//打印出走通后的迷宫  
    }  
}
